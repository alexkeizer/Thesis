{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QIn Lean, new datatypes are generally defined using the keyword, which exposes a high-level, definitional syntax.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QInspiration has also gone the other direction, with Fürer studying quotients of BNFs \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QIt is possible, and indeed common to be generic over the universe of some type parameter, we call such definitions universe polymorphic.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QFunctoriality of type functions.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QA function \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, for some fixed carrier type \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, is called an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-algebra.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QTo clarify, an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-algebra \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is initial, if for every \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-algebra \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q there is exactly one arrow \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q that makes the left square of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q commute.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcofixpoint, of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIf a function takes multiple arguments, it is idiomatic to write them in a curried style, so \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q says that \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a function that takes two arguments, an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, to produce a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QMore concretely, a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-coalgebra is a function \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, with \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q again an arbitrary carrier type, The coalgebra \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is final if for every other \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-coalgebra \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q there is a unique arrow \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q that makes the right square of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q commute.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QNamely, to construct \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q from an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, i.e., use the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q constructor, it expects something of type \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Which is shorthand for, (i : PFin 2) → (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) That is, a function \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and a function \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"SINGULAR_VERB_AFTER_THESE_OR_THOSE","sentence":"^\\QGenerating these is relatively straightforward.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThen, the macrorules part defines the semantics of the macro, as a substitution.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QWe could, in theory, replace the right-hand side of a macrorules match arm with arbitrary code that produces a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q object, and in this way, define a procedural macro.\\E$"}
{"rule":"KIND_OF_A","sentence":"^\\QHence, the type of a command elaborator is \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, where the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q monad allows for four kinds of side effects: Modifying the environment (e.g., \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, def, theorem), Logging messages to inform the user (e.g., \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q), Performing IO, and Throwing errors\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QFor the elaborator, too, we draw inspiration from \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, whose elaborator can be found in the Lean source at Lean/Elab/Declaration.lean and Lean/Elab/Inductive.lean.\\E$"}
