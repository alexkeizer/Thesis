
\chapter{Future considerations / current limitations}%
\label{ch:limitations}


As mentioned before, the implementation is not yet complete.
This chapter will explain some limitations in what is implemented so far, and discuss
directions for future implementation efforts.

\section{Universe Polymorphism}

Recall from~\cref{sec:shape_types} that the procedure starts with synthesizing a head type, roughly like the following:
\begin{leancode}
  inductive HeadT
    | CtorA : HeadT
    | CtorB : HeadT
\end{leancode}
The names and number of constructors will differ, but crucially Lean will generate a \emph{non} universe 
polymorphic type. That is, \lean{HeadT} lives in \lean{Type 0}, and only \lean{Type 0}.
As a result, any QPF defined with \data{}/\codata{} will \emph{not} be universe polymorphic.
Recall the running example of lists,
\begin{leancode}
  data List α 
    | nil  : List α
    | cons : α → List α → List α
\end{leancode}

The \inductive{} analogue of this definition \emph{is} polymorphic, but because of this limitation,
\lean{List} defined in terms of \data{} is \emph{not}.
  

The solution is fairly simple, we can explicitly state that we want \lean{HeadT} to be polymorphic---noting that the child family of types is already universe polymorphic because of the use of \lean{PFin2} (see~\cref{sec:shape_types,sec:enhance:pfin2}).
\begin{badleancode}

  inductive HeadT : Type u
    | CtorA : HeadT
    | CtorB : HeadT

\end{badleancode}

However, there is a bug in the version of Lean we're using (\texttt{nightly-2022-04-28}) 
which causes it to reject the above. 
Newer versions of Lean 4 don't exhibit this bug, so it is easy to remove this limitation after updating
our code to be compatible.
% This bug is already fixed in more recent versions of Lean, 
% so this limitation should be relatively easy to resolve.



\section{Characteristic Theorems}

The formalizations of Avigad \etal{} provide (co)recursion principles, as \lean{Fix.drec} and \lean{Cofix.corec}.
However, because of how these are defined, their signature is quite obscure and not directly suitable for end-users.
\begin{leancode}
  #check @MvQpf.Fix.drec _ List.Internal _
  -- {α : TypeVec 0} →
  --   {β : MvQpf.Fix List.Internal α → Type} →
  --     ((x : List.Internal (α :::ᵥ Sigma β)) → 
  --        β (MvQpf.Fix.mk ((TypeVec.id ::: Sigma.fst) <$$> x))
  --     ) →
  --       (x : MvQpf.Fix List.Internal α) → β x
\end{leancode}

In contrast, the \inductive{} version of \lean{List} defines its recursion principle as
\begin{leancode}
  def List.rec {α : Type _} {motive : QpfList α → Sort _} :
  motive QpfList.nil 
    → ((head : α) → (tail : QpfList α) → motive tail 
                                          → motive (QpfList.cons head tail))
    → (t : QpfList α) 
    → motive t
\end{leancode}

Which is a lot easier to read by comparison. To make our datatypes behave as similarly to Leans native
\inductive{} types, we should generate the same recursion principles as Lean would.
In this particular case, the second recursion principle is fairly easily defined in terms of \lean{MvQpf.Fix.drec}.
\begin{leancode}
  def List.rec {α : Type _} {motive : QpfList α → Sort _} : /- ... -/ :=
    fun nil cons => MvQpf.Fix.drec (fun x => 
      match x with
      | .nil            => nil
      | .cons head tail => cons head tail.fst tail.snd
    )
\end{leancode}

However, once we involve nested induction, the recursion principle generated by Lean becomes more complex.

\begin{leancode}
  inductive Tree (α : Type) where
  | node : α → List (Tree α) → Tree α

  #check @Tree.rec
  -- {α : Type} → {motive_1 : Tree α → Sort u_1} →
  --   {motive_2 : List (Tree α) → Sort u_1} →
  --   ((a : α) → (a_1 : List (Tree α)) 
  --        → motive_2 a_1 → motive_1 (Tree.node a a_1)) →
  --   motive_2 [] →
  --   ((head : Tree α) → (tail : List (Tree α)) 
  --        → motive_1 head → motive_2 tail → motive_2 (head :: tail)) →
  --   (t : Tree α) → motive_1 t
\end{leancode}


More work is required to determine how we can synthesize such specialized recursion principles from
a datatype specification with nested induction, and it should be investigated how mixed induction/coinduction
interacts with such recursors.

Similarly, we should generate no confusion theorems; proving that different combinations of constructors
produce different elements.




\section{User-friendly (co)recursion and (co)induction}
If we just want to do structural recursion on a single variable, it's relatively easy to do so directly
in terms of the fundamental recursion principle.
For example, determining the length of a list.
\begin{leancode}
def List.length : List α → Nat :=
  MvQpf.Fix.rec fun as => match as with
    | .nil                => 0
    | .cons a (as : Nat)  => as + 1 
\end{leancode}

It is important that Lean can statically determine that recursive functions terminate for all 
arguments.\footnote{Lean \emph{can} admit non-terminating functions when they're marked partial, but partial functions are not allowed to be used in proofs}
In the case of this example, termination is straightforward,
but Lean also has a sophisticated \emph{equation compiler} that makes it easy to define functions that recurse
on multiple variables, with support for termination hints, to help when the system fails to automatically proof
termination.

It would be interesting to see if the existing equation compiler mechanisms can be re-used
to also provide a high-level way of defining recursive functions for QPFs, so that users can write
recursive functions on QPF-based datatypes in the same as they would for a regular \inductive{} type.

The dual of termination of recursive functions is productivity of corecursive functions.
\emph{Guarded corecursion} is the trivially productive analogue of structured recursion, 
and supporting an easy syntax for defining guarded corecursive functions would be a great first step.
Further steps might focus on a more general strategy for proving productivity of non-guarded corecursion,
such as~\cite{blanchetteFriendsBenefitsImplementing2017} did for Isabelle.

% \subsection*{Coinduction}

% Analogous to (co)recursive functions are proofs using (co)induction.

% \begin{todo}
%     \begin{itemize}        
%         \item User friendly (co)recursion / (co)induction
%                 \begin{itemize}
%                     \item `eliminator`
%                 \end{itemize}
%     \end{itemize}
% \end{todo}



