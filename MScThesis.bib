@inproceedings{avigadDataTypesQuotients2019,
  title = {Data {{Types}} as {{Quotients}} of {{Polynomial Functors}}},
  booktitle = {10th {{International Conference}} on {{Interactive Theorem Proving}} ({{ITP}} 2019)},
  author = {Avigad, Jeremy and Carneiro, Mario and Hudon, Simon},
  editor = {Harrison, John and O'Leary, John and Tolmach, Andrew},
  year = {2019},
  series = {Leibniz {{International Proceedings}} in {{Informatics}} ({{LIPIcs}})},
  volume = {141},
  pages = {6:1--6:19},
  publisher = {{Schloss Dagstuhl\textendash Leibniz-Zentrum fuer Informatik}},
  address = {{Dagstuhl, Germany}},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.ITP.2019.6},
  isbn = {978-3-95977-122-1},
  keywords = {_tablet,000 Computer science; knowledge; general works,coinductive types,Computer Science,data types,inductive types,polynomial functors},
  note = {\url{https://doi.org/10.4230/LIPIcs.ITP.2019.6}},
  file = {/home/alex/Zotero/storage/FL3P6RZR/Avigad et al. - 2019 - Data Types as Quotients of Polynomial Functors.pdf;/home/alex/Zotero/storage/Q2N47BF6/11061.html}
}

@misc{avigadTheoremProvingLean,
  title = {Theorem {{Proving}} in {{Lean}} 4},
  author = {Avigad, Jeremy and {de Moura}, Leonardo and Kong, Soonho and Ullrich, Sebastian},
  howpublished = {\url{https://leanprover.github.io/theorem_proving_in_lean4/}},
  keywords = {Lean},
  note = {Online Documentation},
  file = {/home/alex/Zotero/storage/4XVPNMJL/theorem_proving_in_lean4.html}
}

@book{awodeyCategoryTheory2010,
  title = {Category Theory},
  author = {Awodey, Steve},
  year = {2010},
  series = {Oxford Logic Guides},
  edition = {Second},
  number = {52},
  publisher = {{Oxford University Press}},
  address = {{Oxford; New York}},
  isbn = {978-0-19-958736-0 978-0-19-923718-0},
  langid = {english},
  lccn = {QA169 .A96 2010},
  keywords = {Categories (Mathematics)},
  file = {/home/alex/Zotero/storage/X8Y2L3KB/Awodey - 2010 - Category theory.pdf}
}

@phdthesis{basoldMixedInductiveCoinductiveReasoning2018,
  title = {Mixed {{Inductive-Coinductive Reasoning Types}}, {{Programs}} and {{Logic}}},
  author = {Basold, H.},
  year = {2018},
  address = {{Nijmegen}},
  abstract = {Induction and coinduction are two complementary techniques used in mathematics and computer science. These techniques occur together, for example, in control systems: On the one hand, control systems are expected to run until turned off and to always react to their environment. This is what we call coinductive computations. On the other hand, they have to make internal computations. Restricting these computations to terminating, that is inductive, computations ensures that the systems continue to react to their environment. We develop in this thesis techniques for programming inductive-coinductive systems, and for describing their properties and proving these properties. The focus is on developing formal languages, in which proofsare written by humans and can be verified by a computer. This ensures the correctness of those proofs and thereby of the programmed systems. Due to their generality, the developed languages are also applicable to the formalisation of mathematics.},
  langid = {english},
  school = {Radboud Universiteit},
  annotation = {Accepted: 2018-04-13T20:35:11Z},
  note = {\url{https://repository.ubn.ru.nl/handle/2066/190323}},
  file = {/home/alex/Zotero/storage/LF7T8NIY/Basold_2018_Mixed Inductive-Coinductive Reasoning Types, Programs and Logic.pdf}
}

@inproceedings{basoldTypeTheoryBased2016,
  title = {Type {{Theory}} Based on {{Dependent Inductive}} and {{Coinductive Types}}},
  booktitle = {Proceedings of the 31st {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Basold, Henning and Geuvers, Herman},
  year = {2016},
  month = jul,
  pages = {327--336},
  publisher = {{ACM}},
  address = {{New York NY USA}},
  doi = {10.1145/2933575.2934514},
  isbn = {978-1-4503-4391-6},
  langid = {english},
  note = {\url{https://dl.acm.org/doi/10.1145/2933575.2934514}},
  file = {/home/alex/Zotero/storage/DDPKZ7CS/Basold_Geuvers_2016_Type Theory based on Dependent Inductive and Coinductive Types.pdf}
}

@misc{biendarraDefiningCoDatatypes,
  title = {Defining ({{Co}})Datatypes and {{Primitively}} ({{Co}})Recursive {{Functions}} in {{Isabelle}}/{{HOL}}},
  author = {Biendarra, Julian and Blanchette, Jasmin and Desharnais, Martin and Panny, Lorenz and Popescu, Andrei and Traytel, Dmitriy},
  abstract = {This tutorial describes the definitional package for datatypes and codatatypes, and for primitively recursive and corecursive functions, in Isabelle/HOL. The following commands are provided: datatype, datatype\_compat, primrec, codatatype, primcorec, primcorecursive, bnf, lift\_bnf, copy\_bnf, bnf\_axiomatization, print\_bnfs, and free\_constructors.},
  howpublished = {\url{https://isabelle.in.tum.de/dist/doc/datatypes.pdf}},
  langid = {english},
  keywords = {_tablet},
  note = {Online Documentation},
  file = {/home/alex/Zotero/storage/M7SHIHPQ/Biendarra et al_Deﬁning (Co)datatypes and Primitively (Co)recursive Functions in Isabelle-HOL.pdf}
}

@incollection{blanchetteFriendsBenefitsImplementing2017,
  title = {Friends with {{Benefits}}: {{Implementing Corecursion}} in {{Foundational Proof Assistants}}},
  shorttitle = {Friends with {{Benefits}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Blanchette, Jasmin Christian and Bouzy, Aymeric and Lochbihler, Andreas and Popescu, Andrei and Traytel, Dmitriy},
  editor = {Yang, Hongseok},
  year = {2017},
  volume = {10201},
  pages = {111--140},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-54434-1_5},
  abstract = {We introduce AmiCo, a tool that extends a proof assistant, Isabelle/HOL, with flexible function definitions well beyond primitive corecursion. All definitions are certified by the assistant's inference kernel to guard against inconsistencies. A central notion is that of friends: functions that preserve the productivity of their arguments and that are allowed in corecursive call contexts. As new friends are registered, corecursion benefits by becoming more expressive. We describe this process and its implementation, from the user's specification to the synthesis of a higher-order definition to the registration of a friend. We show some substantial case studies where our approach makes a difference.},
  isbn = {978-3-662-54433-4 978-3-662-54434-1},
  langid = {english},
  note = {\url{https://doi.org/10.1007/978-3-662-54434-1_5}},
  file = {/home/alex/Zotero/storage/IDP89HIY/Blanchette et al. - 2017 - Friends with Benefits Implementing Corecursion in.pdf;/home/alex/Zotero/storage/YSDWMZG4/Blanchette et al_2017_Friends with Benefits.pdf}
}

@unpublished{christiansenFunctionalProgrammingLean,
  title = {Functional {{Programming}} in {{Lean}}},
  author = {Christiansen, David Thrane},
  keywords = {Lean},
  note = {\url{https://leanprover.github.io/functional_programming_in_lean/}. Online book},
  file = {/home/alex/Zotero/storage/SY68LG8N/functional_programming_in_lean.html}
}

@phdthesis{coquandMetamathematicalInvestigationsCalculus1989,
  type = {Report},
  title = {Metamathematical Investigations of a Calculus of Constructions},
  author = {Coquand, T.},
  year = {1989},
  langid = {english},
  school = {INRIA},
  note = {\url{https://hal.inria.fr/inria-00075471}},
  file = {/home/alex/Zotero/storage/2GZIKEXG/Coquand_1989_Metamathematical investigations of a calculus of constructions.pdf}
}

@inproceedings{demouraLeanTheoremProver2015,
  title = {The {{Lean Theorem Prover}} ({{System Description}})},
  booktitle = {Automated {{Deduction}} - {{CADE-25}}},
  author = {{de Moura}, Leonardo and Kong, Soonho and Avigad, Jeremy and {van Doorn}, Floris and {von Raumer}, Jakob},
  editor = {Felty, Amy P. and Middeldorp, Aart},
  year = {2015},
  volume = {9195},
  pages = {378--388},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-21401-6_26},
  abstract = {Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.},
  isbn = {978-3-319-21400-9 978-3-319-21401-6},
  note = {\url{https://doi.org/10.1007/978-3-319-21401-6_26}},
  file = {/home/alex/Zotero/storage/GLLTAUIJ/de Moura et al_2015_The Lean Theorem Prover (System Description).pdf}
}

@article{furerQuotientsBoundedNatural2022,
  title = {Quotients of {{Bounded Natural Functors}}},
  author = {F{\"u}rer, Basil and Lochbihler, Andreas and Schneider, Joshua and Traytel, Dmitriy},
  year = {2022},
  month = feb,
  journal = {Logical Methods in Computer Science},
  volume = {18},
  number = {1},
  eprint = {2104.05348},
  eprinttype = {arxiv},
  primaryclass = {cs},
  issn = {1860-5974},
  doi = {10.46298/lmcs-18(1:23)2022},
  abstract = {The functorial structure of type constructors is the foundation for many definition and proof principles in higher-order logic (HOL). For example, inductive and coinductive datatypes can be built modularly from bounded natural functors (BNFs), a class of well-behaved type constructors. Composition, fixpoints, and\textemdash under certain conditions\textemdash subtypes are known to preserve the BNF structure. In this article, we tackle the preservation question for quotients, the last important principle for introducing new types in HOL. We identify sufficient conditions under which a quotient inherits the BNF structure from its underlying type. Surprisingly, lifting the structure in the obvious manner fails for some quotients, a problem that also affects the quotients of polynomial functors used in the Lean proof assistant. We provide a strictly more general lifting scheme that supports such problematic quotients. We extend the Isabelle/HOL proof assistant with a command that automates the registration of a quotient type as a BNF, reducing the proof burden on the user from the full set of BNF axioms to our inheritance conditions. We demonstrate the command's usefulness through several case studies.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {_tablet,Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  note = {\url{https://lmcs.episciences.org/9022}},
  file = {/home/alex/Zotero/storage/NHZZBL8R/Fürer et al_2022_Quotients of Bounded Natural Functors.pdf}
}

@inproceedings{gimenezApplicationCoinductiveTypes1996,
  title = {An Application of Co-Inductive Types in {{Coq}}: {{Verification}} of the Alternating Bit Protocol},
  shorttitle = {An Application of Co-Inductive Types in {{Coq}}},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  author = {Gim{\'e}nez, Eduardo},
  editor = {Goos, Gerhard and Hartmanis, Juris and Leeuwen, Jan and Berardi, Stefano and Coppo, Mario},
  year = {1996},
  volume = {1158},
  pages = {135--152},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-61780-9_67},
  abstract = {We describe an experience concerning the implementation and use of co-inductive types in the proof editor Coq. Co-inductive types are recursive types which, opposite to inductive ones, may be inhabited by infinite objects. In order to illustrate their use in Coq, we describe an axiomatisation of a calculus of broadcasting systems where non-ending processes are represented using infinite objects. This calculus is then used for developing a verification proof of the alternating bit protocol.},
  isbn = {978-3-540-61780-8 978-3-540-70722-6},
  note = {\url{https://doi.org/10.1007/3-540-61780-9_67}}
}

@techreport{gimenezTutorialRecursiveTypes1998,
  title = {A {{Tutorial}} on {{Recursive Types}} in {{Coq}}},
  author = {Gim{\'e}nez, Eduardo},
  year = {1998},
  month = may,
  institution = {{INRIA}},
  abstract = {This document is an introduction to the definition and use of recursive types in the Coq proof environment. It explains how recursive types like natural numbers and infinite streams are defined in Coq, and the kind of proof techniques that can be used to reason about them (case analysis, induction, inversion of predicates, co-induction, etc). Each technique is illustrated through an executable and self-contained Coq script.},
  note = {\url{https://hal.inria.fr/inria-00069950/document}}
}

@phdthesis{girardInterpretationFonctionelleElimination1972,
  title = {Interpr\'etation Fonctionelle et \'Elimination Des Coupures de l'arithm\'etique d'ordre Sup\'erieur},
  author = {Girard, J.},
  year = {1972},
  address = {{Paris}},
  school = {Universit\'e Paris}
}

@book{gordonEdinburghLCFMechanised1979,
  title = {Edinburgh {{LCF}}: A Mechanised Logic of Computation},
  shorttitle = {Edinburgh {{LCF}}},
  author = {Gordon, Michael J. C. and Milner, R. and Wadsworth, Christopher P.},
  year = {1979},
  series = {Lecture Notes in Computer Science},
  number = {78},
  publisher = {{Springer-Verlag}},
  address = {{Berlin ; New York}},
  isbn = {978-0-387-09724-4},
  lccn = {QA9.59 .G67},
  keywords = {Computable functions,Data processing,Edinburgh LCF (Computer system)}
}

@book{milewskiCategoryTheoryProgrammers2019,
  title = {Category {{Theory}} for {{Programmers}}},
  author = {Milewski, Bartosz},
  year = {2019},
  publisher = {{Lightning Source UK}},
  address = {{Milton Keynes}},
  isbn = {978-0-464-24387-8},
  langid = {english},
  keywords = {Category Theory},
  file = {/home/alex/Zotero/storage/MTC6KB9L/Milewski - Category Theory for Programmers.pdf}
}

@inproceedings{nakataProofPearlFan2011,
  title = {A {{Proof Pearl}} with the {{Fan Theorem}} and {{Bar Induction}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Nakata, Keiko and Uustalu, Tarmo and Bezem, Marc},
  editor = {Yang, Hongseok},
  year = {2011},
  volume = {7078},
  pages = {353--368},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-25318-8_26},
  abstract = {We study temporal properties over infinite binary red-blue trees in the setting of constructive type theory. We consider several familiar path-based properties, typical to linear-time and branching-time temporal logics like LTL and CTL*, and the corresponding tree-based properties, in the spirit of the modal \$\#956;-calculus. We conduct a systematic study of the relationships of the path-based and tree-based versions of "eventually always blueness" and mixed inductive-coinductive "almost always blueness" and arrive at a diagram relating these properties to each other in terms of implications that hold either unconditionally or under specific assumptions (Weak Continuity for Numbers, the Fan Theorem, Lesser Principle of Omniscience, Bar Induction).    We have fully formalized our development with the Coq proof assistant.},
  isbn = {978-3-642-25317-1 978-3-642-25318-8},
  note = {\url{https://doi.org/10.1007/978-3-642-25318-8_26}}
}

@unpublished{paulinoMetaprogrammingLean,
  title = {Metaprogramming in {{Lean}} 4},
  author = {Paulino, Arthur and Testa, Damiano and Ayers, Edward and B{\"o}ving, Henrik and Limperg, Jannis and Gadgil, Siddhartha and Bhat, Siddharth},
  langid = {english},
  keywords = {_tablet},
  note = {Online Book. \url{https://github.com/arthurpaulino/lean4-metaprogramming-book}},
  file = {/home/alex/Zotero/storage/STURDSJ9/Paulino et al_Metaprogramming in Lean 4.pdf}
}

@inproceedings{themathlibcommunityLeanMathematicalLibrary2020,
  title = {The Lean Mathematical Library},
  booktitle = {Proceedings of the 9th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {{The mathlib Community}},
  year = {2020},
  month = jan,
  pages = {367--381},
  publisher = {{ACM}},
  address = {{New Orleans LA USA}},
  doi = {10.1145/3372885.3373824},
  isbn = {978-1-4503-7097-4},
  langid = {english},
  keywords = {formal proof,Lean},
  note = {\url{https://dl.acm.org/doi/10.1145/3372885.3373824}},
  file = {/home/alex/Zotero/storage/X5R7F6YP/The mathlib Community_2020_The lean mathematical library.pdf}
}

@mastersthesis{traytelCategoryTheoryBased,
  title = {A Category Theory Based (Co)Datatype Package for {{Isabelle}}/{{HOL}}},
  author = {Traytel, Dmytro},
  address = {{M\"unchen}},
  langid = {english},
  school = {TU M\"unchen},
  note = {\url{https://www21.in.tum.de/~traytel/mscthesis.pdf}},
  file = {/home/alex/Zotero/storage/AQIK6MRC/Traytel - A category theory based (co)datatype package for I}
}

@article{ullrichNotationsHygienicMacro2022,
  title = {Beyond {{Notations}}: {{Hygienic Macro Expansion}} for {{Theorem Proving Languages}}},
  shorttitle = {Beyond {{Notations}}},
  author = {Ullrich, Sebastian and {de Moura}, Leonardo},
  year = {2022},
  month = apr,
  journal = {Logical Methods in Computer Science},
  volume = {18},
  number = {2},
  publisher = {{Episciences.org}},
  doi = {10.46298/lmcs-18(2:1)2022},
  abstract = {In interactive theorem provers (ITPs), extensible syntax is not only crucial to lower the cognitive burden of manipulating complex mathematical objects, but plays a critical role in developing reusable abstractions in libraries. Most ITPs support such extensions in the form of restrictive ``syntax sugar'' substitutions and other ad hoc mechanisms, which are too rudimentary to support many desirable abstractions. As a result, libraries are littered with unnecessary redundancy. Tactic languages in these systems are plagued by a seemingly unrelated issue: accidental name capture, which often produces unexpected and counterintuitive behavior. We take ideas from the Scheme family of programming languages and solve these two problems simultaneously by proposing a novel hygienic macro system custom-built for ITPs. We further describe how our approach can be extended to cover type-directed macro expansion resulting in a single, uniform system offering multiple abstraction levels that range from supporting simplest syntax sugars to elaboration of formerly baked-in syntax. We have implemented our new macro system and integrated it into the new version of the Lean theorem prover, Lean 4. Despite its expressivity, the macro system is simple enough that it can easily be integrated into other systems.},
  langid = {english},
  keywords = {_tablet,Computer Science - Programming Languages},
  note = {\url{https://doi.org/10.46298/lmcs-18(2:1)2022}},
  file = {/home/alex/Zotero/storage/VQABD6ES/Ullrich_de Moura_2022_Beyond Notations.pdf}
}

@article{uustaluDualSubstitutionRedecoration2002,
  title = {The Dual of Substitution Is Redecoration},
  author = {Uustalu, Tarmo and Vene, Varmo},
  year = {2002},
  journal = {Trends in Functional Programming 3},
  pages = {99--110},
  abstract = {It is well known that type constructors of incomplete trees (trees with variables) carry the structure of a monad with substitution as the extension operation. Less known are the facts that the same is true of type constructors of incomplete cotrees (=non-wellfounded trees) and that the corresponding monads exhibit a special structure. We wish to draw attention to the dual facts which are as meaningful for functional programming: type constructors of decorated cotrees carry the structure of a comonad with redecoration as the coextension operation, and so do\textemdash even more interestingly\textemdash type constructors of decorated trees.},
  note = {\url{http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcAuth=ORCID&SrcApp=OrcidOrg&DestLinkType=FullRecord&DestApp=WOS_CPL&KeyUT=WOS:000181626000009&KeyUID=WOS:000181626000009}}
}
