@article{avigadDataTypesQuotients2019a,
  title = {Data {{Types}} as {{Quotients}} of {{Polynomial Functors}}},
  author = {Avigad, Jeremy and Carneiro, Mario and Hudon, Simon},
  date = {2019},
  pages = {19},
  publisher = {{Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany}},
  doi = {10.4230/LIPICS.ITP.2019.6},
  url = {http://drops.dagstuhl.de/opus/volltexte/2019/11061/},
  urldate = {2022-11-23},
  abstract = {A broad class of data types, including arbitrary nestings of inductive types, coinductive types, and quotients, can be represented as quotients of polynomial functors. This provides perspicuous ways of constructing them and reasoning about them in an interactive theorem prover.},
  editora = {Wagner, Michael},
  editoratype = {collaborator},
  langid = {english},
  version = {1.0},
  keywords = {_tablet,000 Computer science; knowledge; general works,Computer Science},
  file = {/home/alex/Zotero/storage/QYJXL9SD/Avigad et al_2019_Data Types as Quotients of Polynomial Functors.pdf;/home/alex/Zotero/storage/Q2N47BF6/11061.html}
}

@online{avigadTheoremProvingLean,
  title = {Theorem {{Proving}} in {{Lean}} 4 - {{Theorem Proving}} in {{Lean}} 4},
  author = {Avigad, Jeremy and de Moura, Leonardo and Kong, Soonho and Ullrich, Sebastian},
  options = {useprefix=true},
  url = {https://leanprover.github.io/theorem_proving_in_lean4/},
  urldate = {2022-11-25},
  keywords = {Lean},
  file = {/home/alex/Zotero/storage/4XVPNMJL/theorem_proving_in_lean4.html}
}

@book{awodeyCategoryTheory2010,
  title = {Category Theory},
  author = {Awodey, Steve},
  date = {2010},
  series = {Oxford Logic Guides},
  edition = {2},
  number = {52},
  publisher = {{Oxford University Press}},
  location = {{Oxford ; New York}},
  isbn = {978-0-19-958736-0 978-0-19-923718-0},
  langid = {english},
  pagetotal = {311},
  keywords = {Categories (Mathematics)},
  file = {/home/alex/Zotero/storage/X8Y2L3KB/Awodey - 2010 - Category theory.pdf}
}

@article{biendarraDefiningCoDatatypes,
  title = {Defining ({{Co}})Datatypes and {{Primitively}} ({{Co}})Recursive {{Functions}} in {{Isabelle}}/{{HOL}}},
  author = {Biendarra, Julian and Blanchette, Jasmin and Desharnais, Martin and Panny, Lorenz and Popescu, Andrei and Traytel, Dmitriy},
  pages = {64},
  abstract = {This tutorial describes the definitional package for datatypes and codatatypes, and for primitively recursive and corecursive functions, in Isabelle/HOL. The following commands are provided: datatype, datatype\_compat, primrec, codatatype, primcorec, primcorecursive, bnf, lift\_bnf, copy\_bnf, bnf\_axiomatization, print\_bnfs, and free\_constructors.},
  langid = {english},
  keywords = {_tablet},
  file = {/home/alex/Zotero/storage/M7SHIHPQ/Biendarra et al_Deﬁning (Co)datatypes and Primitively (Co)recursive Functions in Isabelle-HOL.pdf}
}

@incollection{blanchetteFriendsBenefitsImplementing2017,
  title = {Friends with {{Benefits}}: {{Implementing Corecursion}} in {{Foundational Proof Assistants}}},
  shorttitle = {Friends with {{Benefits}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Blanchette, Jasmin Christian and Bouzy, Aymeric and Lochbihler, Andreas and Popescu, Andrei and Traytel, Dmitriy},
  editor = {Yang, Hongseok},
  date = {2017},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {10201},
  pages = {111--140},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-662-54434-1_5},
  url = {https://link.springer.com/10.1007/978-3-662-54434-1_5},
  urldate = {2023-01-15},
  abstract = {We introduce AmiCo, a tool that extends a proof assistant, Isabelle/HOL, with flexible function definitions well beyond primitive corecursion. All definitions are certified by the assistant’s inference kernel to guard against inconsistencies. A central notion is that of friends: functions that preserve the productivity of their arguments and that are allowed in corecursive call contexts. As new friends are registered, corecursion benefits by becoming more expressive. We describe this process and its implementation, from the user’s specification to the synthesis of a higher-order definition to the registration of a friend. We show some substantial case studies where our approach makes a difference.},
  isbn = {978-3-662-54433-4 978-3-662-54434-1},
  langid = {english},
  file = {/home/alex/Zotero/storage/IDP89HIY/Blanchette et al. - 2017 - Friends with Benefits Implementing Corecursion in.pdf}
}

@online{christiansenFunctionalProgrammingLean,
  title = {Functional {{Programming}} in {{Lean}}},
  author = {Christiansen, David Thrane},
  url = {https://leanprover.github.io/functional_programming_in_lean/},
  urldate = {2022-11-25},
  organization = {{Functional Programming in Lean}},
  keywords = {Lean},
  file = {/home/alex/Zotero/storage/SY68LG8N/functional_programming_in_lean.html}
}

@thesis{coquandMetamathematicalInvestigationsCalculus1989,
  type = {report},
  title = {Metamathematical Investigations of a Calculus of Constructions},
  author = {Coquand, T.},
  date = {1989},
  institution = {{INRIA}},
  url = {https://hal.inria.fr/inria-00075471},
  urldate = {2023-01-10},
  langid = {english},
  file = {/home/alex/Zotero/storage/2GZIKEXG/Coquand_1989_Metamathematical investigations of a calculus of constructions.pdf}
}

@inproceedings{demouraLeanTheoremProver2015,
  title = {The {{Lean Theorem Prover}} ({{System Description}})},
  booktitle = {Automated {{Deduction}} - {{CADE-25}}},
  author = {de Moura, Leonardo and Kong, Soonho and Avigad, Jeremy and van Doorn, Floris and von Raumer, Jakob},
  editor = {Felty, Amy P. and Middeldorp, Aart},
  options = {useprefix=true},
  date = {2015},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {9195},
  pages = {378--388},
  publisher = {{Springer International Publishing}},
  location = {{Cham}},
  doi = {10.1007/978-3-319-21401-6_26},
  url = {http://link.springer.com/10.1007/978-3-319-21401-6_26},
  urldate = {2023-01-10},
  abstract = {Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.},
  isbn = {978-3-319-21400-9 978-3-319-21401-6},
  file = {/home/alex/Zotero/storage/GLLTAUIJ/de Moura et al_2015_The Lean Theorem Prover (System Description).pdf}
}

@article{furerQuotientsBoundedNatural2022,
  title = {Quotients of {{Bounded Natural Functors}}},
  author = {Fürer, Basil and Lochbihler, Andreas and Schneider, Joshua and Traytel, Dmitriy},
  date = {2022-02-01},
  journaltitle = {Logical Methods in Computer Science},
  volume = {Volume 18, Issue 1},
  eprint = {2104.05348},
  eprinttype = {arxiv},
  primaryclass = {cs},
  pages = {7354},
  issn = {1860-5974},
  doi = {10.46298/lmcs-18(1:23)2022},
  url = {http://arxiv.org/abs/2104.05348},
  urldate = {2022-10-30},
  abstract = {The functorial structure of type constructors is the foundation for many definition and proof principles in higher-order logic (HOL). For example, inductive and coinductive datatypes can be built modularly from bounded natural functors (BNFs), a class of well-behaved type constructors. Composition, fixpoints, and—under certain conditions—subtypes are known to preserve the BNF structure. In this article, we tackle the preservation question for quotients, the last important principle for introducing new types in HOL. We identify sufficient conditions under which a quotient inherits the BNF structure from its underlying type. Surprisingly, lifting the structure in the obvious manner fails for some quotients, a problem that also affects the quotients of polynomial functors used in the Lean proof assistant. We provide a strictly more general lifting scheme that supports such problematic quotients. We extend the Isabelle/HOL proof assistant with a command that automates the registration of a quotient type as a BNF, reducing the proof burden on the user from the full set of BNF axioms to our inheritance conditions. We demonstrate the command’s usefulness through several case studies.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {_tablet,Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/alex/Zotero/storage/NHZZBL8R/Fürer et al_2022_Quotients of Bounded Natural Functors.pdf}
}

@inproceedings{gimenezApplicationCoinductiveTypes1996,
  title = {An Application of Co-Inductive Types in {{Coq}}: {{Verification}} of the Alternating Bit Protocol},
  shorttitle = {An Application of Co-Inductive Types in {{Coq}}},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  author = {Giménez, Eduardo},
  editor = {Berardi, Stefano and Coppo, Mario},
  date = {1996},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {1158},
  pages = {135--152},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-61780-9_67},
  url = {http://link.springer.com/10.1007/3-540-61780-9_67},
  urldate = {2023-01-10},
  abstract = {We describe an experience concerning the implementation and use of co-inductive types in the proof editor Coq. Co-inductive types are recursive types which, opposite to inductive ones, may be inhabited by infinite objects. In order to illustrate their use in Coq, we describe an axiomatisation of a calculus of broadcasting systems where non-ending processes are represented using infinite objects. This calculus is then used for developing a verification proof of the alternating bit protocol.},
  editorb = {Goos, Gerhard and Hartmanis, Juris and Leeuwen, Jan},
  editorbtype = {redactor},
  isbn = {978-3-540-61780-8 978-3-540-70722-6}
}

@inproceedings{gimenezTutorialRecursiveTypes1998,
  title = {A {{Tutorial}} on {{Recursive Types}} in {{Coq}}},
  author = {Giménez, Eduardo},
  date = {1998-05-01},
  url = {https://www.semanticscholar.org/paper/A-Tutorial-on-Recursive-Types-in-Coq-Gim%C3%A9nez/86fb31bb5bb8c43a385c656c1994ba9d86781651},
  urldate = {2023-01-10},
  abstract = {This document is an introduction to the definition and use of recursive types in the Coq proof environment. It explains how recursive types like natural numbers and infinite streams are defined in Coq, and the kind of proof techniques that can be used to reason about them (case analysis, induction, inversion of predicates, co-induction, etc). Each technique is illustrated through an executable and self-contained Coq script.}
}

@article{girardInterpretationFonctionelleElimination1972,
  title = {Interprétation Fonctionelle et Élimination Des Coupures de l'arithmétique d'ordre Supérieur},
  author = {Girard, J.},
  date = {1972-01-01}
}

@book{gordonEdinburghLCFMechanised1979,
  title = {Edinburgh {{LCF}}: A Mechanised Logic of Computation},
  shorttitle = {Edinburgh {{LCF}}},
  author = {Gordon, Michael J. C. and Milner, R. and Wadsworth, Christopher P.},
  date = {1979},
  series = {Lecture Notes in Computer Science},
  number = {78},
  publisher = {{Springer-Verlag}},
  location = {{Berlin ; New York}},
  isbn = {978-0-387-09724-4},
  pagetotal = {159},
  keywords = {Computable functions,Data processing,Edinburgh LCF (Computer system)}
}

@article{milewskiCategoryTheoryProgrammers,
  title = {Category {{Theory}} for {{Programmers}}},
  author = {Milewski, Bartosz},
  pages = {498},
  langid = {english},
  keywords = {Category Theory},
  file = {/home/alex/Zotero/storage/MTC6KB9L/Milewski - Category Theory for Programmers.pdf}
}

@article{paulinoMetaprogrammingLean,
  title = {Metaprogramming in {{Lean}} 4},
  author = {Paulino, Arthur and Testa, Damiano and Ayers, Edward and Böving, Henrik and Limperg, Jannis and Gadgil, Siddhartha and Bhat, Siddharth},
  pages = {82},
  langid = {english},
  keywords = {_tablet},
  file = {/home/alex/Zotero/storage/STURDSJ9/Paulino et al_Metaprogramming in Lean 4.pdf}
}

@inproceedings{themathlibcommunityLeanMathematicalLibrary2020,
  title = {The Lean Mathematical Library},
  booktitle = {Proceedings of the 9th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {{The mathlib Community}},
  date = {2020-01-20},
  pages = {367--381},
  publisher = {{ACM}},
  location = {{New Orleans LA USA}},
  doi = {10.1145/3372885.3373824},
  url = {https://dl.acm.org/doi/10.1145/3372885.3373824},
  urldate = {2023-01-10},
  eventtitle = {{{POPL}} '20: 47th {{Annual ACM SIGPLAN Symposium}} on {{Principles}} of {{Programming Languages}}},
  isbn = {978-1-4503-7097-4},
  langid = {english},
  keywords = {formal proof,Lean},
  file = {/home/alex/Zotero/storage/X5R7F6YP/The mathlib Community_2020_The lean mathematical library.pdf}
}

@article{traytelCategoryTheoryBased,
  title = {A Category Theory Based (Co)Datatype Package for {{Isabelle}}/{{HOL}}},
  author = {Traytel, Dmytro},
  pages = {58},
  langid = {english},
  file = {/home/alex/Zotero/storage/AQIK6MRC/Traytel - A category theory based (co)datatype package for I}
}

@misc{ullrichNotationsHygienicMacro2022,
  title = {Beyond {{Notations}}: {{Hygienic Macro Expansion}} for {{Theorem Proving Languages}}},
  shorttitle = {Beyond {{Notations}}},
  author = {Ullrich, Sebastian and de Moura, Leonardo},
  options = {useprefix=true},
  date = {2022-04-12},
  number = {arXiv:2001.10490},
  eprint = {2001.10490},
  eprinttype = {arxiv},
  primaryclass = {cs},
  publisher = {{arXiv}},
  url = {http://arxiv.org/abs/2001.10490},
  urldate = {2022-10-30},
  abstract = {In interactive theorem provers (ITPs), extensible syntax is not only crucial to lower the cognitive burden of manipulating complex mathematical objects, but plays a critical role in developing reusable abstractions in libraries. Most ITPs support such extensions in the form of restrictive “syntax sugar” substitutions and other ad hoc mechanisms, which are too rudimentary to support many desirable abstractions. As a result, libraries are littered with unnecessary redundancy. Tactic languages in these systems are plagued by a seemingly unrelated issue: accidental name capture, which often produces unexpected and counterintuitive behavior. We take ideas from the Scheme family of programming languages and solve these two problems simultaneously by proposing a novel hygienic macro system custom-built for ITPs. We further describe how our approach can be extended to cover type-directed macro expansion resulting in a single, uniform system offering multiple abstraction levels that range from supporting simplest syntax sugars to elaboration of formerly baked-in syntax. We have implemented our new macro system and integrated it into the new version of the Lean theorem prover, Lean 4. Despite its expressivity, the macro system is simple enough that it can easily be integrated into other systems.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {_tablet,Computer Science - Programming Languages},
  file = {/home/alex/Zotero/storage/VQABD6ES/Ullrich_de Moura_2022_Beyond Notations.pdf}
}

@article{uustaluDualSubstitutionRedecoration2002,
  title = {The Dual of Substitution Is Redecoration},
  author = {Uustalu, Tarmo and Vene, Varmo},
  date = {2002},
  journaltitle = {Trends in Functional Programming 3},
  pages = {99--110},
  url = {http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcAuth=ORCID&SrcApp=OrcidOrg&DestLinkType=FullRecord&DestApp=WOS_CPL&KeyUT=WOS:000181626000009&KeyUID=WOS:000181626000009},
  urldate = {2022-11-28},
  abstract = {It is well known that type constructors of incomplete trees (trees with variables) carry the structure of a monad with substitution as the extension operation. Less known are the facts that the same is true of type constructors of incomplete cotrees (=non-wellfounded trees) and that the corresponding monads exhibit a special structure. We wish to draw attention to the dual facts which are as meaningful for functional programming: type constructors of decorated cotrees carry the structure of a comonad with redecoration as the coextension operation, and so do—even more interestingly—type constructors of decorated trees.}
}
