\documentclass[titlepage]{report}

%
%   PACKAGES   
%

\usepackage{illcmolthesis}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{unicode-math}
\usepackage{verbatim}   % for the comment environment
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{framed}

% 
%   Minted
% 

\usepackage[outputdir=./out]{minted}

% instruct minted to use our local theorem.py
\newmintinline[lean]{lean4.py:Lean4Lexer -x}{fontsize=\small}
\newminted[leancode]{lean4.py:Lean4Lexer -x}{fontsize=\small}

% Lean code that does not typecheck/compile
\newminted[badleancode]{lean4.py:Lean4Lexer -x}{%
    fontsize=\small,%
    frame=leftline,%
    framesep=0mm,%
    rulecolor=red%
}

% Disable the red boxed minted will put around "syntax errors" 
\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}




%   
%   Font
% 

\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{fontspec}

% switch to a monospace font supporting more Unicode characters
\setmonofont{JetBrains Mono NL Light}
% \setmonofont{Droid Sans Mono}

\newfontfamily{\freemono}{FreeMono}
\newfontfamily{\droidmono}{Droid Sans Mono}
\newfontfamily{\jbmono}{JetBrains Mono NL Light}

\newunicodechar{→}{\ensuremath{\rightarrow}}
\newunicodechar{⟹}{\ensuremath{\Longrightarrow}}
\newunicodechar{⋅}{\ensuremath{\cdot}}

\newunicodechar{α}{{\droidmono α}}
\newunicodechar{β}{{\droidmono β}}
\newunicodechar{γ}{{\droidmono γ}}
\newunicodechar{₁}{\ensuremath{_\texttt{1}}}
\newunicodechar{₂}{\ensuremath{_\texttt{1}}}
\newunicodechar{ᵢ}{\ensuremath{_\texttt{i}}}
\newunicodechar{ₙ}{\ensuremath{_\texttt{n}}}

% 
% \usepackage[GreekAndCoptic]{ucharclasses}
% \setTransitions{GreekAndCoptic}{}{}


% 
%   Spacing & Layout
% 

\usepackage{geometry}

\geometry{
    hmargin=10em
}
\frenchspacing
\setlength{\parskip}{6pt}
\setlength{\parindent}{0pt}



% 
%   Custom environments
% 
\definecolor{shadecolor}{HTML}{F8E0E0}

% definitions
\newenvironment{definition}[1][Definition:]{\begin{trivlist}                         
    \item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
    
% remark    
% \newenvironment{remark}{\begin{trivlist}                         
%   \item[\hskip \labelsep {\bfseries Remark:}]}{\end{trivlist}}



\newenvironment{remark}{%
% \def\FrameCommand{\colorbox{remarkcolor}}%
% \MakeFramed{\advance\hsize-\width \FrameRestore}%
\begin{framed}
\begin{trivlist}
    \item[\hskip \labelsep {\bfseries Remark:}]}%
{%
\end{trivlist}%
\end{framed}
    % \endMakeFramed%
}
    

% todo
\newenvironment{todo}{%
\definecolor{shadecolor}{HTML}{F8E0E0}%
\begin{shaded}%
\begin{trivlist}                         
    \item[\hskip \labelsep {\bfseries Todo:}]}{\end{trivlist}\end{shaded}}

% hidden code    
\newenvironment{leanhidden}{\expandafter\comment}{\expandafter\endcomment}



% 
%   Custom commands
% 
\newcommand\inductive{\lean{inductive}}
\newcommand\data{\lean{data}}
\newcommand\codata{\lean{codata}}
\newcommand\Type{\lean{Type}}
\newcommand\Typen[1]{\lean{Type #1}}

\begin{document}

%
%   TITLE PAGE
%
\title{TITLE OF THE THESIS}
\author{Alex C.\,Keizer}
\birthdate{October 15th, 1998}
\birthplace{Alkmaar, The Netherlands}
\defensedate{T.B.D, 2022}
\supervisor{Dr Jasmin Blanchette}
\supervisor{Dr Benno van der Berg}
\committeemember{T.B.D.}
% \committeemember{Prof Dr Jane Williams}
% \committeemember{Dr Jill Jones}
% \committeemember{Dr Albert Heijn}
\maketitle


\begin{leanhidden}
    import Qpf.Macro

    namespace Thesis
\end{leanhidden}

%
%   TEXT
%
\chapter{Introduction}
\label{ch:intro}

Much of logic is built on a framework of induction.
It is no surprise, then, that Lean -- an interactive theorem prover / dependently typed, functional programming
language -- is based on induction as well.
Specifically, the calculus of constructions with inductive definitions.

To define a new type, users will generally employ the \inductive keyword, which has a syntax similar
to other functional languages, like Haskell.

\begin{leancode}
    inductive List α 
    | nil  : List α
    | cons : α → List α → List α
\end{leancode}

Read as follows: \texttt{List} has two \emph{constructors}, i.e., ways to construct a list.
\texttt{List.nil} is a constant
representing the empty list; 
\texttt{List.cons head tail}, where \texttt{head} is of type \texttt{α} and \texttt{tail} is another list of \texttt{α}s, representing the operation of adding a new element to the front of
an existing list.

The \texttt{α} is a type parameter, meaning we are generic over the type of elements in a list;
\texttt{List Nat} is a list of natural numbers, while \texttt{List String} is a list of strings.

So, \inductive encompasses three notions: 
\begin{itemize}
    \item Sums/disjoint unions (by having multiple constructors)
    \item Products (by having a constructor take multiple arguments)
    \item Recursion/induction
\end{itemize}

The inductive interpretation means that every element of an inductive type consists of only
finitely many applications of its constructors. In particular, it is not possible
to construct a list with an infinite chain of \text{cons} applications
%LEANIGNORE
\begin{center}
    \texttt{cons 0 (cons 1 (cons 2 (cons 3 (cons 4 ( cons 5 ... )))))}
\end{center}
The recursion must end in \texttt{nil} at some point, \texttt{List} represent only finite lists.
\footnote{Contrast this with Haskell, which does allow for infinite lists with a similar definition, due to its lazy semantics}


Now, the case of (countably) infinite lists (also called streams) has a simple enough encoding in Lean, as a function from natural numbers to the parameter type.
\begin{leancode}
    def Stream α := Nat → α
\end{leancode}

If, instead, we want to allow for both finite and infinite lists, we can take the sum of these types.
\begin{leancode}
    inductive FinOrInfList α
    | fin : List α      -- a finite list, or
    | inf : Stream α    -- an infinite list
\end{leancode}

And like this we can come quite far with ad-hoc encodings. 
However, Lean lacks a comprehensive solution to defining infinite data structures.
Ideally, there would be a way for users to write a specification with the same syntax as
\inductive, but have it be interpreted \emph{coinductively} instead.

I have implemented a \codata macro in Lean 4 to do exactly this.
For example, the following is automatically compiled into something equivalent to \texttt{FinOrInfList}.

\begin{leancode}
    codata CoList α 
    | nil  : CoList α
    | cons : α → CoList α → CoList α
\end{leancode}

It is \emph{compositional}, allowing us to use \texttt{CoList} in the definition of subsequent types, either inductive or coinductive.
However, \codata types are built on a foundation of QPFs (Quotients of Polynomial Functors, we will explain these later), and only compose well with types that are themselves QPFs. 
The \codata macro will recognize when the newly defined type is a QPF (again, we will explain later under which conditions this is true), and automatically register it as such.

One could manually prove that an \inductive type is a QPF, and it will compose without problems, but
we also provide a \data to define inductive types using a similar procedure as \codata.
Types defined as \data that fit the criteria of QPFs, are thus automatically registered as well.

To wit, the following defines a tree of finite depth (because of the inductive interpretation of \data), but whose nodes have potentially infinitely many children (because they are stored in a \texttt{CoList}).

\begin{leancode}
    data RoseTree α
    | node : α → CoList (RoseTree α) → RoseTree α
\end{leancode}

If we actually wanted trees of infinite depth, but where node have finitely many children, we can easily define that as well.
\begin{leancode}
    data List' α -- equivalent to List, but using data
    | nil  : List' α
    | cons : α → List' α

    codata RoseTree2 α β
    | node : α → List' (RoseTree α) → RoseTree α
\end{leancode}

\begin{todo}
    Talk about recursion and corecursion principles?
\end{todo}


The work was partly inspired by a similar effort to add (co)datatypes to Isabelle/HOL (another interactive theorem prover), 
and greatly based on work by Avigad et al that established how coinductive types can be encoded in Lean
(namely, through QPFs, or Quotients of Polynomial Functors) and provided formalizations of the relevant constructions -- albeit in Lean 3, while we are using Lean 4. \cite{biendarraDefiningCoDatatypes}\cite{avigadDataTypesQuotients2019a}

The main contribution of this work is thus to port those formalization to Lean 4,
to establish a procedure for translating specifications using the \inductive syntax into the
appropriate constructions on QPFs, and to provide a proof of concept implementation of the \data and \codata macros.

\begin{todo}
    Improve the following descriptions
\end{todo}

\Cref{ch:background} will explain what QPFs are;
\cref{ch:porting} will detail the process of porting the QPF formalizations from Lean 3 to Lean 4;
\cref{ch:enhancing} will describe the enhancements we made to thsee formalizations, which go beyond just porting;
\cref{ch:procedure} will establish the translation procedure used by \data and \codata;
\cref{ch:implementing} will go into more technical detail about the (proof of concept)
implementation of these macros, and the Lean 4 meta-programming system;
finally, \cref{ch:conclusion} will show the limitations of the current implementation, discuss potential improvements, and conclude the thesis.

The proof of concept code can be found at \url{https://github.com/alexkeizer/qpf4}, it provides the \data and \codata commands discussed so far, alongside a \texttt{qpf} command and \texttt{fin\_destr} tactic.

The code snippets in this thesis are tested with version \texttt{leanprover/lean4:nightly-2022-04-28}. Code that (intentionally) does not typecheck, is typeset with a red line, like so:
\begin{badleancode}

    def Foo := Bar -- whoops, Bar does not exist

\end{badleancode}











\chapter{Background}
\label{ch:background}

A key concept for the rest of this thesis will be QPF (Quotient of Polynomial Functor), and how we can use them to encode (co)inductive types.

We will assume as little background as possible, yet, some (minimal) exposure to Category Theory and Functional Programming concepts will be benificial to understanding.

\begin{todo}
    Add references?
\end{todo}

\begin{remark}
    We will use remarks like this one \emph{below} code snippets to explain Lean syntax and concepts that might not be familiar. We don't assume any knowledge of Lean, but the interested reader is invited to consult the online documentation\cite{avigadTheoremProvingLean}, or ``Functional Programming in Lean'' for a more comprehensive introduction to Lean.\cite{christiansenFunctionalProgrammingLean}
\end{remark}



The encoding of types as QPFs relies on a key observation; a lot of types are functorial in nature.
Take, for example, the inductive type of lists we saw in the introduction.
\begin{leancode}
    inductive List α 
    | nil  : List α
    | cons : α → List α → List α
\end{leancode}

This defines a function \texttt{List} that takes a type, and returns a new type.
We call such functions \emph{type functions}.

\begin{remark}
    Here we mean function in a very concrete sense. In a dependently typed language, such as Lean, types \emph{are} terms. In particular, things like \texttt{Nat} and \texttt{String} are types, but they are also \emph{values} of type \Type.
    The signature of \texttt{List}, then, is \lean{Type → Type}.
    So, \Type is the ``type of types'', but it is itself also a value.
    Section \ref{sec:bg:universes} will cover what, then, is the type of \Type.
\end{remark}

There is also an obvious mapping function \lean{map : (f : α → β) → List α → List β}, 
which applies the function \texttt{f} to each element of the argument list.

\begin{remark}
    \lean{map : α} is Lean syntax for ``\texttt{map} is a value of type \texttt{α}'', and \lean{α → β} is the type of functions from \texttt{α} to \texttt{β}. 
    If a function takes multiple arguments, it is idiomatic to write them in a \emph{curried} style,
    so \lean{f : α → β → γ} says that \texttt{f} is a function that takes two arguments, an \texttt{α} and a \texttt{β}, to produce a \texttt{γ}. Arrows are right-associative.

    Finally, \lean{(a : α) → β} is a \emph{dependent} arrow; it is a function from \texttt{α} to \texttt{β}, with the possibility to make the resulting type depend on the \emph{value} \texttt{a} of the first argument. 
    We used this syntax in the definition of \texttt{map} above, even though it is a regular, non-dependent function, just to give a name to the first argument. 
    It would have been equivalent to write \lean{map : (α → β) → List α → List β}.
    Notice also that actually \texttt{α} and \texttt{β} range over all types and are thus arguments to \texttt{map}. Since the value of \texttt{α} and \texttt{β} can be inferred from the other arguments, though, there is no need to supply values for them when calling \texttt{map}, they are implicit arguments. It is possible to explicate implicit arguments, so technically the signature of map is 
    \begin{center}
    \lean{map: {α : Type} → {β : Type} → (α → β) → List α → List β}
    \end{center}
    However, Lean will automatically add implicit arguments for free variables, so long as it can infer which type this variable should have, so we will generally not add binders for implicit variables. Instead, we adopt the convention that \texttt{α} and \texttt{β} always refers to types. 
\end{remark}

\begin{todo}
    Should I explain the exact functor constraints here, or just leave it as is?
\end{todo}

Together, a type function \lean{F : Type → Type} and a mapping operation \texttt{map : (f: α → β) → F α → F β} form a \emph{functor}, as long as they preserve: 
\begin{itemize}
    \item identity maps, so \texttt{F (id α) = id (F α)} (with \texttt{id : (α : Type) → α → α} the map from a type to the identity function on that type)
    \item compositions, so \texttt{(map f) ∘ (map g) = map (f ∘ g)}
\end{itemize}
\texttt{List α} is an example of a functor, but so are products (\texttt{α × β}) and sums 
(\texttt{α ⊕ β})

A function \texttt{f : F α → α} is an \emph{\texttt{F}-algebra}, and inductive types are, in essence, defined by an \emph{initial} such algebra. An \texttt{F}-algebra \texttt{f} is initial, if for every \texttt{F}-algebra \texttt{g} there is exactly one arrow that makes the following square commute.
\begin{todo}
    initial algebra commuting square
\end{todo}

Consider the functor \lean{def F α := Unit ⊕ α}, where \texttt{Unit} is a type with exactly one inhabitant, with the algebra \texttt{f : F ℕ → ℕ} that maps the unit case to $0 ∈ \mathbb{N}$ and maps $n ∈ ℕ$ to $n + 1$

\begin{todo}
    Explain connection between inductive types and initial algebras
\end{todo}

Similarly, there is a connection between coinductive types and final coalgebras.

But, not all functor have initial algebras and final coalgebras. And, it is not, in general, easy to construct such (co)algebras from the specification of an arbitrary functor.


\section{Polynomial functors}
Of special interest are \emph{polynomial functors}, which, intuitively, can be composed from a few primitive operations (such as constants, sums, products and exponentials).
More formally, we say that a polynomial functor is defined by a set $A$ and an $A$-indexed family of sets $B_a$ as
\[
    P(X) = \Sigma_{a ∈ A} B_a \rightarrow X  
\]
That is, $P(X)$ is the disjoint union of all functions from $B_a$ to $X$, for every $a ∈ A$.
In the theory, we generally still refer to functors that are not defined in this form, but are isomorphic to a polynomial functor in the strict sense, as polynomial.

To encode this in Lean, we replace ``set'' with ``type'' and obtain the following.
\footnote{To remain consistent, we will use Lean 4 syntax and naming conventions throughout the whole thesis, even though we are still discussing the formalizations as established by Avigad et al here. The difference with the Lean definitions presented in this chapter, and those presented in their original work are superficial.}
\begin{leancode}
    structure PFunctor := (A : Type) (B : A → Type)
\end{leancode}

\begin{remark}
    \lean{structure} is a simple wrapper around \inductive, for when there is only one constructor.
    The above is equivalent to
    \begin{leancode}
        inductive PFunctor 
        | mk : (A : Type) → (B : A → Type) → PFunctor
    \end{leancode}
\end{remark}

Then, the operations on types and functions are straightforward
\begin{leancode}
    /-- Applying `P` to an object of `Type` -/
    def PFunctor.Obj (P : PFunctor) (α : Type)
        := Σ x : P.A, P.B x → α

    /-- Applying `P` to a morphism of `Type` -/
    def PFunctor.map (P : PFunctor) (f : α → β) : P.Obj α → P.Obj β 
        := fun ⟨a, g⟩ => ⟨a, f ∘ g⟩
\end{leancode}

\begin{remark}
    Variable \texttt{P} is known to be of type \texttt{PFunctor}, so \texttt{P.Obj} is recognized as \texttt{PFunctor.Obj P}. Similarly, as \texttt{PFunctor} has only one constructor, the anonymous constructor syntax \texttt{⟨a, g⟩} is translated to an application of this constructor.
    Finally, \lean{fun ⟨a, g⟩ => _} defines a function that takes a single argument \texttt{x : P.Obj α}, and deconstructs it into the constituent elements \texttt{a : P.A} and \texttt{g : P.B a → α}.
\end{remark}

So an element of \texttt{P.Obj α} is a (dependent) pair of a \emph{shape} $a ∈ A$ and a function $g : B_a \rightarrow \alpha$, representing the \emph{contents}. A mapped function \texttt{P.map f} then leaves the shape as is, and precomposes $f$ with the content $g$.

\begin{todo}
    \begin{enumerate}
        \item W-types
        \item M-types
    \end{enumerate}
\end{todo}

\section{Quotients}
Lean supports quotient types, it is common, e.g., to define a multiset as the equivalence of lists through the relation that equates lists up to permutation.


\begin{todo}
    \begin{itemize}
        \item Multiset example
        \item Impossible with pfunctor
        \item Show QPF definition (univariate, without universes)
        \item Note that we don't specifically look at quotients in the rest of the thesis, but we do do \data and \codata constructions as QPFs, which compose well. Still, the current implementation breaks when trying to use quotients. (reference limitations section)
    \end{itemize}
\end{todo}











\section{Type Universes}
\label{sec:bg:universes}

A big strength of Lean is that it treats types as first class. Just like \texttt{0} is a value of type \texttt{Nat}, the type \texttt{Nat} is itself a \emph{value}, of type \Type (the ``type of types''). Because types are also values, \Type needs a type to live in as well. Setting \lean{(Type: Type)} would lead to unsoundness, so instead, there is a notion of \emph{type universes}. We have that \lean{Type : Type 1}, \lean{Type 1 : Type 2}, and in general, \lean{Type u : Type (u+1)}. In fact, \lean{Type} is just a shorthand for \lean{Type 0}, the smallest type universe.

Universe levels are essentially natural numbers, but they are \textbf{not} first class values, and are indeed very different from elements of \lean{Nat}.
In particular, when writing \Typen{u}, the universe \texttt{u} is \textbf{not} a normal term, there is a separate grammar, with some minimal builtin operations, that defines valid universe levels.

We \emph{can} make our definitions generic over which universe to work in, this is called \emph{universe polymorphism}. The polymorphic definition of a polynomial functor looks like
\begin{leancode}
    universe u

    structure PFunctor := (A : Type u) (B : A → Type u)
\end{leancode}
Where the first command declares that \texttt{u} is a universe variable in subsequent definitions.
When referring to \texttt{PFunctor}, we can specify a universe to work in by writing \texttt{PFunctor.\{u\}}. A similar syntax also introduces a universe variable that is local to a single definition.

\begin{leancode}
    def PFunctor.Obj.{v} (P : PFunctor.{v}) (α : Type v)
        := Σ x : P.A, P.B x → α
\end{leancode}

Note that usually we don't have to be this explicit. Lean will usually infer the right universe levels, when left unspecified.
For example, with \texttt{map} as before, Lean recognizes that (with the new definition of \texttt{PFunctor}) the implicit arguments \texttt{α} and \texttt{β} live in \Typen{u} and that \texttt{P} is a \texttt{PFunctor.\{u\}}, for some universe variable \texttt{u}.
\begin{leancode}
    def PFunctor.map (P : PFunctor) (f : α → β) : P.Obj α → P.Obj β 
        := fun ⟨a, g⟩ => ⟨a, f ∘ g⟩    
\end{leancode}


\section{Multivariate Functors}
Earlier, we mentioned that sums and products (written as \texttt{α ⊕ β} and \texttt{α × β}, respectively, in Lean) are functorial in both arguments.
They are, in fact, polynomial, but, both take two types as arguments and don't fit in the definitions presented so far. We have to generalize from the univariate case to \emph{multivariate} functors.

It is difficult to reason about $n$-ary curried functions, where $n$ is arbitrary, so instead we wuse the following, \emph{uncurried} representation of multivariate type functions.

\begin{leancode}
    def TypeFun (n : Nat) := (TypeVec.{u} n) → Type v
\end{leancode}
Where \texttt{TypeVec} is a \emph{type vector}, i.e., a list of exactly $n$ elements of \Typen{u}.
Notice that the arguments all live in universe $u$, but the result lives in a potentially different universe $v$. 
Most constructions do require that these universes coincide, and use \texttt{TypeFun.\{u,u\}}.

Suppose that \texttt{Sum'} is the uncurried version of sums, then we would write \texttt{Sum' ![α, β]} to use it with argument types α and β. The \texttt{map} operation now takes not one function, but a vector (i.e., list) of $n$ functions, each going from \texttt{αᵢ} to \texttt{βᵢ}. 

\begin{leancode}
    map : {α β : TypeVec n} → (α ⟹ β) → F α → F β
\end{leancode}
\begin{remark}
    Suppose that $v_0 = {!}[α_0, α_1, ..., α_{n-1}]$ and $v_1 = {!}[β_0, β_1, ..., β_{n-1}]$ are type vectors (of length $n$), then we write $v₀ ⟹ v₁$ for the type of vectors of functions $α₀ → β₀$, $α₁ → β₁$, ..., $α_{n-1} → β_{n-1}$.
\end{remark}
\begin{remark}
    Objects of type \texttt{TypeVec n}, for some fixed but arbitrary length $n$, and morphisms \texttt{(⋅ ⟹ ⋅)} form a category. 
    Multivariate type functors are in fact nothing more than (univariate) functors on this category of type vectors.
\end{remark}

Thus, if \texttt{f : α₀ → β₀} and \texttt{g : α₁ → β₁}, then \texttt{Sum'.map ![f, g]} yields a function from \texttt{Sum' ![α₀, α₁]} to \texttt{Sum' ![β₀, β₁]}.
The functoriality constraints have an obvious generalization to the multivariate case.

\subsection{Multivariate Polynomial Functors}
An $n$-ary, polynomial functor is still defined with a shape $A$ as before, but the content now maps $a ∈ A$ not to a single type, but to a vector of $n$ types.

\begin{leancode}
    structure MvPFunctor (n : Nat) := (A : Type u) (B : A → TypeVec.{u} n)
\end{leancode}

The generalization proceeds relatively straightforwardly.
\begin{leancode}
    def MvPFunctor.Obj (P : MvPFunctor.{u} n) : TypeFun.{u,u} n
        := fun (α : TypeVec n) => Σ a : P.A, P.B a ⟹ α

    def MvPFunctor.map  (P : MvPFunctor.{u} n) 
                        (f : v₀ ⟹ v₁) 
                            : P.Obj v₀ → P.Obj v₁ 
        := fun ⟨a, g⟩ => ⟨a, TypeVec.comp f g⟩
\end{leancode}

Where \texttt{TypeVec.comp} is the pointwise composition of two vectors of functions.

\begin{remark}
    Implicit variables are not limited to types, we will use \texttt{n} and \texttt{m} for natural numbers and \texttt{v₀, v₁, ...} for type vectors.
\end{remark}

The generalization of M and W-types to the multivariate case is left as an exercise for the reader.

\subsection{Multivariate QPFs}

\begin{todo}
    List the full definition of MvQpf with universes
\end{todo}


\section{Inductive Families}
It is important to clarify that we're only considering inductive \emph{types}, 
for which the recursive occurrences of the type being declared must not use other values for the type parameters. Lean also has inductive \emph{families} of types for which this restriction does not hold.

Consider, for example, an inductive definition of vectors, i.e., lists of known length $n$.
\begin{badleancode}
    inductive BadVector (α : Type u) (n : Nat)
    | nil   : BadVector α 0
    | cons  : α → BadVector α n → BadVector α (n+1)
\end{badleancode}

This won't compile, because this defines an inductive type, and the constructors mention \texttt{BadVector α 0} and \texttt{BadVector α (n+1)}, while they are only allowed to mention \texttt{BadVector α n}.

It is only variable \texttt{n} that changes. The syntax for an inductive family is very similar; we can promote \texttt{n} from parameter to \emph{index} by removing the binder, and giving a type signature.

\begin{leancode}
    inductive GoodVector (α : Type u) : Nat → Type _
    | nil   : GoodVector α 0
    | cons  : α → GoodVector α n → GoodVector α (n+1)
\end{leancode}

Inductive families do not correspond to initial algebras in the same way that inductive types do, and the constructions as QPFs \emph{fundamentally} don't support inductive families, nor the coinductive analogue.
Hence, we shall limit ourselves to just (co)inductive types.




\chapter{Porting the QPF formalization from Lean3 to Lean4}
\label{ch:porting}








%LEAN namespace Enhancing
\chapter{Enhancing the QPF formalization}
\label{ch:enhancing}


In the preceding chapter we presented the formalization of QPFs as made by Avigad et al.
In the process of porting the code from Lean3 to Lean4, 
I identified, and indeed implemented, various enhancements. 

These chapter thus serves to elaborate on these changes to the existing behaviour which are too big
to be considered just porting, but don't fall strictly under (co)datatype synthesis and metaprogramming parts of the project.




\section{Functions \& Currying}
Like most functional languages, in Lean it is idiomatic to write functions in their curried form, 
so \lean{f : Type → Type → Type}, rather than \lean{f : (Type × Type) → Type}.

However, in the formalization of QPF, we're working with functions of arbitrary arity $n$, and it 
is difficult to express concepts such as ``the result of applying $n$ arguments to $f$'' while remaining
general with respect to the value of $n$ when $f$ is curried.

So instead, the formalizations work with the notion of an (uncurried) type function.

%LEAN namespace Hidden -- hide definition, so it does not interfere
\begin{leancode}
    abbrev TypeFun (n : Nat)
      := TypeVec n → Type v
\end{leancode}
%LEAN end Hidden

Which is a function that takes a list of exactly $n$ types, and returns a type --- the \texttt{u} and
\texttt{v} refer to the respective universes that these types live in, and betray a technical limitation
of this encoding: all arguments to a \lean{TypeFun} must live in the same universe.

There is an obvious translation from \lean{TypeFun} to a curried type function and, vice versa, from
a function taking $n$ types from the same universe and returning a type, to a \lean{TypeFun n}.
I have implemented these conversions as \lean{TypeFun.toCurried} and \lean{TypeFun.ofCurried}, respectively,
and proven that these functions are isomorphisms. 

To wit, they function as expected:
\begin{leancode}
    variable (F : TypeFun 2) (F' : Type 1 → Type 1 → Type 2)
    example : F.curried α β = F ![α, β]                 := by rfl
    example : F' α β = (TypeFun.ofCurried F') ![α, β]   := by rfl
\end{leancode}

We could write down the type of \texttt{F'} in the way we're used to writing function types, since
we fixed a particular arity. 
It becomes a bit trickier to name the type of curried functions of arbitrary arity.
Thus, \lean{CurriedFun α β n} is a recursively defined alias for \lean{α → ... → α → β}, 
taking $n$ arguments of type \texttt{α}.
\begin{leancode}
    abbrev CurriedFun (α : Type u) (β : Type v) : Nat → Type (max u v)
      | 0   => PUnit.{u+1} → β
      | 1   => α → β
      | n+1 => α → CurriedFun α β n
\end{leancode}
Intuitively one might expect a \lean{CurriedFun} taking no arguments (so, $n = 0$) to be equal to 
just \lean{β}, but that does not typecheck --- \lean{Type v} and \lean{Type (max u v)} are not, in general, the same type.
One might be able to lift \texttt{β} into the right universe, but such functions are not particularly
interesting anyways, so I opted for the simpler solution: functions that take no arguments are
functions from the unit type.
% \footnote{Well, \texttt{PUnit}, which is the universe polymorphic unit type}

A curried type function is just an instance of \lean{CurriedFun}.
\begin{leancode}
    abbrev CurriedTypeFun := CurriedFun (Type u) (Type v)
\end{leancode}



Considering all this complexity, it is easy to see why Avigad et al made all the formalizations and
constructions in terms of uncurried functions. 
Still, uncurried functions feel very unidiomatic and users will rightfully expect their (co)datatypes
to function as curried type functions. 
It would be interesting to see whether it is possible to reformulate the formalization of QPFs in
terms of curried functions. 
For the time being, we'll satisfy ourselves with hiding these details throughs
\lean{TypeFun.curried} and \lean{TypeFun.ofCurried} conversions.



\section{MvQpf}
The following change might feel overwhelmingly underwhelming, but it presents a considerably quality 
of life improvement for the \lean{MvQpf} typeclass. Originally, the latter was defined as
\begin{leancode}
    class MvQpf {n : Nat} (F : TypeFun n) [MvFunctor F] where
        -- ...
\end{leancode}
This makes sense, \texttt{F} can only be a QPF if it is a functor in the first place.
However, when declared like this, the type of \lean{MvQpf} is 
\begin{leancode}
    #check (MvQpf : {n : Nat} → (F : TypeFun n) → [MvFunctor F] → Type _)
\end{leancode}
In particular, this means we cannot write \lean{MvQpf F}, unless an instance of \lean{MvFunctor F}
can be inferred. For concrete QPFs this is generally not problematic, but when \texttt{F} is a
variable, this restriction becomes annoying. 

For example, 
\begin{leancode}
    variable (F : TypeFun n) [MvQpf F]
\end{leancode}

So before we can s



\section{VecMvFunctor}

The original formulation of 







\begin{leanhidden}
    end Enhancing

    namespace Procedure
\end{leanhidden}




\chapter{A procedure for synthesizing functors from a specification}
\label{ch:procedure}

This chapter will establish a procedure that transforms a specifications of a (co)datatype
into the proper constructions on QPFs.
It will do so in the abstract, focusing on the details of the procedure, rather than implementation
details of the Lean meta-programming system (which will be covered in the next chapter).


\section{Shape types}

Arguably the simplest, and most fundamental, inductive types are \lean{Sum α β} and \lean{Prod α β},
representing "either α or β" and "a pair of α and β", respectively.
They can be defined as

\begin{center}
\begin{minipage}[t]{0.45\linewidth}
    \begin{leancode}
inductive Sum α β
  | inl : α → Sum α β
  | inr : β → Sum α β
    \end{leancode}
\end{minipage}
\begin{minipage}[t]{0.45\linewidth}
    \begin{leancode}    
inductive Prod α β
  | mk : α → β → Prod α β
    \end{leancode}
\end{minipage}
\end{center}

They are also examples of what we will call \emph{shape} types.
\begin{definition}
    A \emph{shape} type is an inductive type \lean{Foo α_1, ..., α_n}, 
    where each constructor takes only arguments of types in $\{α_1, ..., α_n\}$.
\end{definition}
That is, each constructor's arguments must be typed as one of the parameters to the shape type.
Let's make this a bit clearer by look at examples that are \textbf{not} shape types. 

%LEAN namespace BadExample
\begin{leancode}
    inductive MyList α
      | nil  : MyList α 
      | cons : α → MyList α → MyList α

    inductive ListWrapper α
      | mk : List α → ListWrapper α

    inductive NatWrapper
      | mk : Nat → NatWrapper
\end{leancode}
%LEAN end BadExample

The only parameter to \lean{MyList} is α, but the \lean{cons} constructor takes a \lean{MyList α} as second argument,
so \lean{MyList} is not a shape type.
Similarly, \lean{ListWrapper.mk} (resp. \lean{NatWrapper.mk}) takes an argument of type \lean{List α} (resp. \lean{Nat}),
which are not type parameters, so these types are not shapes either.

Notice that shape types are non-recursive and do not depend on any other types, as a direct consequence 
of the definition. This makes them easy to translate into a polynomial functor. 

\begin{remark}
    One way to do this translation is to realize that all shape functors can be defined as a
    composition of sums and products. 
    This is similar to what the datatype package for Isabelle/HOL does.
    We'll use a different, slightly more monolithic approach.
\end{remark}

Recall that polynomial functors are defined as
\begin{leancode}
    structure MvPFunctor (n : Nat) :=
      (A : Type u) (B : A → TypeVec n)
\end{leancode}


Let us return to the example of sum and product types. 
For the ``head'' type (\lean{A}), we will take a type that has exactly as many constructor as
the shape type, but such that each constructor is a constant (i.e., takes no arguments).
Note that the head type does not take any type parameters. 

\begin{center}
    \begin{minipage}[t]{0.45\linewidth}
        \begin{leancode}
    inductive Sum.HeadT
      | inl : Sum.HeadT
      | inr : Sum.HeadT
        \end{leancode}
    \end{minipage}
    \begin{minipage}[t]{0.45\linewidth}
        \begin{leancode}    
    inductive Prod.HeadT
      | mk : Prod.HeadT
        \end{leancode}
    \end{minipage}
\end{center}

The ``child'' family of types maps each constructor $c$ to a vector of types \lean{α_c}.
What is most important is the cardinality of each type \lean{α_c i}, 
because that is what determines the number of arguments of the $i$-th type parameter are needed
to use constructor $c$. 

The concrete structure of these types is not relevant, so we'll always use \lean{PFin2 m}, the type
of natural numbers less than $m$, to construct a type with cardinality $m$.

\begin{remark}
    Note that \lean{PFin2 m} is a type we defined ourselves. We prefer it over \lean{Fin m}, a similar
    type defined by the lean standard library, because our version is \emph{universe polymorphic}.
    We will come back later to what this means and why it is important.
\end{remark}

So, we start by counting for each constructor, how many times it takes an argument of type \lean{α_i},
for each parameter \lean{α_i}.
\begin{center}
\begin{tabular}{l|c|c}
    & α & β \\ \hline
    \texttt{Sum.inl}  & 1 & 0 \\
    \texttt{Sum.inr}  & 0 & 1 \\
    \texttt{Prod.mk}  & 1 & 1 \\    
\end{tabular}    
\end{center}

Using these counts, we define the child family of types, and subsequently, the polynomial functor.

\begin{center}
  \begin{leancode}
    def Sum.ChildT : Sum.HeadT → TypeVec 2
      | .inl => ![PFin2 1, PFin2 0]
      | .inr => ![PFin2 0, PFin2 1]

    def Prod.ChildT : Prod.HeadT → TypeVec 2
      | .mk  => ![PFin2 1, PFin2 1]
  \end{leancode}
\end{center}

\begin{remark}
    If the interpreter knowns which type to expect, say \texttt{Sum.HeadT}, and we write an identifier with a leading
    dot, like \texttt{.inl}, then it will automatically add the type as namespace, concluding that
    we must mean \texttt{Sum.HeadT.inl}.
\end{remark}
From here on, the construction is the same for both types;
We'll show it just for \texttt{Sum}.
\begin{center}
    \begin{leancode}
    def Sum.P  : MvPFunctor 2 := MvPFunctor.mk Sum.HeadT  Sum.ChildT

    
    def QpfSum.Internal : TypeFun 2  := MvPFunctor.Obj Sum.P
    def QpfSum : Type → Type → Type := TypeFun.curried QpfSum.Internal

    -- instance : MvQpf 
  \end{leancode}
\end{center}



\begin{todo}
    Show that QpfSum.Internal has an instance of MvQpf
\end{todo}

And we're done! However, these qpf-based versions of the types are still not very nice to use.
For example, if we want to construct a pair in \lean{QpfProd}, we have to go through \lean{MvPFunctor.mk},
which encodes its arguments in a not user-friendly way. 
Namely, to construct \texttt{Sum α β} from an \texttt{(a : α)}, i.e., use the \texttt{inl} constructor, 
it expects something of type
\begin{center}
    \lean{(Sum.ChildT .inl) ⟹ ![α, β]}
\end{center}
Which is shorthand for, 
\begin{center}
    (i : PFin 2) → (\lean{![PFin2 1, PFin 0] i → ![α, β] i})
\end{center}
That is, a function \lean{PFin2 1 → α} and a function \lean{PFin2 0 → β}.
\begin{remark}
    Note that vectors are indexed right-to-left, so \texttt{![α, β]} is β
    and \texttt{![α, β] 1} is α
\end{remark}

Recall that we defined vectors of size $n$ as functions \texttt{PFin2 n → α}, so 


\begin{leancode}
    def QpfSum.inl {α β} (a : α) : QpfSum α β :=
      MvPFunctor.mk .inl (fun (i : PFin 2) => match i with
        | 1 => ![a]
        | 0 => ![]
      )
\end{leancode}


We could generate these constructors automatically, but the inner details will still be exposed
when a user tries to destruct an element of \texttt{QpfSum α β}.
Clearly, this is not an ideal definition.

\subsection{MvQpf.ofPolynomial}
The solution is to not reinvent the wheel quite as much.
The \lean{inductive} version of \texttt{Sum} and \texttt{Prod} (and, indeed any shape type) works
perfectly fine, and is much easier to work with than the polynomial functor-based version.

In fact, the goal of this part of the procedure is not to redefine shape types, it is to show that
they are QPFs by deriving an instance of \texttt{MvQpf} (for the uncurried version).
The way to do this is \texttt{MvQpf.ofPolynomial}.

%LEANIGNORE
\begin{leancode}
    def ofPolynomial {F : TypeFun n} 
                     (P : MvPFunctor n) 
                     (box    : ∀{α}, F α → P.Obj α) 
                     (unbox  : ∀{α}, P.Obj α → F α) 
                     (box_unbox_id : ∀{α} (x : P.Obj α), box (unbox x) = x)
                     (unbox_box_id : ∀{α} (x : F α), unbox (box x) = x)
                  : MvQpf F
        := _ -- body omitted
\end{leancode}

If we can provide an isomorphism between \texttt{TypeFun.ofCurried Sum} and the polynomial functor \texttt{Sum.P}, 
then \texttt{ofPolynomial} shows that the former is a QPF.

\begin{todo}
    Maybe explain how box, unbox, etc. are generated?
\end{todo}






\section{Recursive and corecursive types}
Now we know how to turn any shape type into a qpf-based datatype.
If a type is recursive, but otherwise does not mention other types, we can transform it into a shape
type.
Namely, by adding an extra variable and substituting it for all (co)recursive occurences of the type
to be defined.

For example, the shape of \texttt{MyList α}, defined at the start of the previous section, is
\begin{leancode}
    inductive List.Shape α ρ
      | nil  : Shape α ρ
      | cons : α → ρ → Shape α ρ
\end{leancode}
This is a valid shape type, so we follow the procedure above to derive an instance of \texttt{MvQpf}.
To get rid of the extra variable \texttt{ρ}, we simply take the fixpoint.
\begin{leancode}
    def QpfList.Internal : TypeFun 2 
        := MvQpf.Fix (TypeFun.ofCurried MyList.Shape)

\end{leancode}

\begin{todo}
    Explain cofixpoint
\end{todo}



\section{Composition pipeline}
Finally, we are ready to discuss (co)datatypes that are composed of other (co)datatypes.

The running example for this section will be the rose tree; leaves are labelled with \texttt{α}, while
internal nodes are labelled with \texttt{β} and can have an finite, non-zero number of children.
\begin{leancode}
    data QpfTree α β
      | leaf : α → QpfTree α β
      | node : β → QpfTree α β → QpfList (QpfTree α β) → QpfTree α β
\end{leancode}

The type is recursive, so we introduce the fresh parameter as before.
\begin{leancode}
    data QpfTree.Nonrecursive α β ρ
      | leaf : α → QpfTree α β ρ
      | node : β → ρ → QpfList ρ → QpfTree α β ρ
\end{leancode}

Then, we go through each argument type which is not just a parameter, and substitute
it with a fresh parameter.

\begin{leancode}
    data QpfTree.Shape α β ρ σ₁
      | leaf : α → QpfTree α β ρ σ₁
      | node : β → ρ → σ₁ → QpfTree α β ρ σ₁
\end{leancode}
Remembering that \texttt{σ₁} stands for \texttt{QpfList ρ}, so we should define the following 
composition, in such a way that \texttt{F} is a QPF.
%LEANIGNORE
\begin{leancode}
    def F α β ρ := QpfTree.Shape α β ρ (QpfList ρ)
\end{leancode}


\subsection{Parameter reuse}
Of course, multiple occurences of the same non-parameter type don't nead a fresh variable each.
Suppose we had a constructor that takes two list, like
%LEANIGNORE
\begin{leancode}
    | node₂ : β → ρ → QpfList ρ → QpfList ρ → QpfTree α β ρ
\end{leancode}
Then we can reuse the same fresh parameter \texttt{σ₁} for both occurences.
%LEANIGNORE
\begin{leancode}
    | node₂ : β → ρ → σ₁ → σ₁ → QpfTree α β ρ σ₁
\end{leancode}

On the other hand, if a non-parameter type also occurs as a subexpression of another type, then
we will not substitute it with the same parameter.
The example gets a bit contrived, but suppose nodes take both a list of children, and a nested list 
of lists of children.
%LEANIGNORE
\begin{leancode}
    | node₃ : β → ρ → QpfList ρ → QpfList (QpfList ρ) → QpfTree α β ρ
\end{leancode}
Then we can reuse the same fresh parameter \texttt{σ₁} for both occurences.
%LEANIGNORE
\begin{leancode}
    | node₃ : β → ρ → σ₁ → σ₂ → QpfTree α β ρ σ₁ σ₂
\end{leancode}
Where \texttt{σ₁} stands for \texttt{QpfList ρ}, as before, and \texttt{σ₂} stands for 
\texttt{QpfList (QpfList ρ)}.

\begin{todo}
    Bring attention back to the initial example
\end{todo}


\subsection{Solving for compositions}

The question remains, how do we show that \texttt{F} is a QPF.
Recall the desired definition is
%LEANIGNORE
\begin{leancode}
    def F α β ρ := QpfTree.Shape α β ρ (QpfList ρ)
\end{leancode}

Well, it is a composition, so we look at 

\begin{todo}
    Explain solving for compositions
    - MvQpf.Comp
    - then a family of functors Gi with constraints
    - Projections
    - Constants
\end{todo}




\section{Universe considerations}
\begin{todo}
    Explain universe polymorphism (i.e., why PFin2).

    Explain why HeadT is not universe polymorphic yet (bug in our version of lean)
\end{todo}


\section{A final example}
\begin{todo}
    Do the entire procedure for
    codata NatStream
    | mk : Nat → NatStream → NatStream
\end{todo}




\newpage 
\newpage








We will start by giving example specifications, and showing how to represent each as a (co)fixpoint
of a QPF manually.

The \lean{inductive} keyword encompasses three concepts: sums, products, and recursion.
Let's forget about the latter for a second, and look at a non-recursive type
\begin{leancode}
    inductive Foo (α β γ : Type)
    | bar : α → β → Foo α β γ
    | qux : γ → Foo α β γ
\end{leancode}
We can replace the two arguments of the \lean{bar} constructor by their product.
\begin{leancode}
    inductive Foo₂ (α β γ : Type)
    | bar : (α × β) → Foo₂ α β γ
    | qux : γ → Foo₂ α β γ
\end{leancode}
Having two constructor with a single argument just means taking their sum.
\begin{leancode}
    def Foo₃ (α β γ : Type) :=
        (α × β) ⊕ β
\end{leancode}




\section{Polynomial Functors}

Recall that we formalized polynomial functors, and their action on types, as  
\begin{leancode}
    structure MvPFunctor (n : Nat) :=
        (A : Type u) (B : A → TypeVec.{u} n)

    def MvPFunctor.Obj (P : MvPFunctor n) : TypeFun n
        := fun α => Σ a : P.A, P.B a ⟹ α
\end{leancode}

That is, a polynomial functor $P$ is defined by some type $A$, where each element represents some 
constructor of type $P(x_0, ..., x_{n-1})$, and a family of types $B_{a, i}$, with $a ∈ A$ and $i < n$, 
where each element of $B_{a,i}$ is a label for an argument of type $x_i$ needed by constructor $a$.

These can of course be any type, and this flexibility is useful in certain constructions,
but ultimately the functor is defined by their \emph{cardinality}, i.e., how many inhabitants types 
$A$ and $B_{a,i}$ have. Any additional structure of these types is not relevant for the behaviour of 
the functor.

Consequently, we can express any polynomial functor (up to isomorphism, at least) with the following
shorthand.

\begin{leancode}
    def MvPFunctor.mk' {n : Nat} (ctors : List (Vec Nat n)) 
        : MvPFunctor n
    :=  let A := PFin2 ctors.length
        let B := fun a i => PFin2 (ctors.get a.toFin i)
        ⟨A, B⟩
\end{leancode}

Here \lean{PFin2 n} is the type of natural numbers strictly less than $n$, which gives us an easy
way to construct types of arbitrary (but finite) cardinality $n$.

In effect, \lean{ctors} is a matrix of fixed width $n$ (but arbitrary height). 
Each row represents a constructor, the value in the $i$-th column tells us how many elements of the 
$i$-th type argument are required in the constructor.

\subsubsection*{Products \& Sums}
For example, consider a (binary) product, which could be inductively defined as 
\begin{leancode}
    inductive Prod α β
      | mk : α → U → Prod T U
\end{leancode}

We can define the corresponding functor, using our abbreviation as
\begin{leancode}
    def Prod.P : MvPFunctor 2 
      := .mk' [
        ![1, 1]
      ]
\end{leancode}
At a glance, we see that \lean{P ![α, β]} has a single constructor, and this constructor takes one
argument of type \lean{α} and one argument of \lean{β}.
This definition corresponds to the following
\begin{leancode}
    def Prod.P' : MvPFunctor 2 
      :=  let A := PFin2 1
          let B := fun _ => ![PFin2 1, PFin2 1]
          ⟨A, B⟩
\end{leancode}



Another fundamental functor is the (binary) sum. Inductively, it looks like this
\begin{leancode}
    inductive Sum α β 
      | inl : α → Sum α β 
      | inl : β → Sum α β 
\end{leancode}
It has two constructors, so we use a matrix with two rows to define the polynomial functor.
\begin{leancode}
    def Sum.P : MvPFunctor
\end{leancode}




\subsection*{Universe polymorphism}

As an aside, Lean does provide a standard \lean{Fin n} type which encodes naturals less than $n$.
However, \lean{Fin n} has type \lean{Type}, which forces the arguments to any functor \lean{P} with
\lean{P.A = Fin n} to be in \lean{Type 0} as well.

To illustrate, here is a definition of the product functor, but now in terms of \lean{Fin}
\begin{leancode}
    def Prod.Q : MvPFunctor 2 
      :=  let A := Fin 1
          let B := fun _ => ![Fin 1, Fin 1]
          ⟨A, B⟩

    -- `Nat` lives in `Type', so both functors are fine
    #check  
\end{leancode}
First, consider the pair \lean{(Nat, Nat)}. \lean{Nat} lives in \lean{Type}, so both functors are 
fine
\begin{leancode}
    #check (P.Obj ![Nat, Nat] : Type)       -- ✓
    #check (Q.Obj ![Nat, Nat] : Type)       -- ✓
\end{leancode}
Then, suppose some \lean{X} that lives in a higher universe.
\lean{P} is able to adjust. 
\begin{leancode}
    variable (X : Type 1)
    #check (P.Obj ![X, X] : Type 1)         -- ✓
\end{leancode}
However, \lean{Q} complains that it expects \lean{X} to live in \lean{Type}.
\begin{leancode}    
    #check Q.Obj ![X, X]                    -- ×            
    -- application type mismatch
    --   Vec.append1 Vec.nil X
    -- argument
    --   X
    -- has type
    --   Type 1 : Type 2
    -- but is expected to have type
    --   Type : Type 1
\end{leancode}

Note that \lean{P} still requires all arguments to live in the same universe, so
\begin{leancode}
    #check P.Obj ![X, Nat]                  -- ×
\end{leancode}
%     -- application type mismatch
%     --   Vec.append1 (Vec.append1 Vec.nil ℕ) X
%     -- argument
%     --   X
%     -- has type
%     --   Type 1 : Type 2
%     -- but is expected to have type
%     --   Type : Type 1
% \end{leancode}
does not typecheck.



\subsection*{Sum}
For example, the type \lean{Sum T U}, representing the disjoint union of types \lean{T} and \lean{U},
is a polynomial functor. It could be specified as:
\begin{leancode}
    data Sum T U
    | inl : T → Sum T U
    | inr : U → Sum T U
\end{leancode}
For $A$, we take a simple enumeration of the constructors
\begin{leancode}
    inductive Sum.A
    | inl : Sum.A
    | inr : Sum.A
\end{leancode}
For $B$, we use the following
\begin{leancode}
    def Sum.B : Sum.A → TypeVec n
    | .inl => ![Unit, Empty]
    | .inr => ![Empty, Unit]
\end{leancode}
This means that an element of \lean{Sum T U} made with constructor \lean{inl} contains one inhabitant of \lean{T} (\lean{Unit} has exactly one inhabitant) and no inhabitants of \lean{U} (as the name implies, \lean{Empty} is not inhabited). Conversely, elements made with constructor \lean{inr} contain one inhabitant of \lean{U} and no inhabitant of \lean{T}.





















\chapter{Implementing the procedure as a proof of concept}
\label{ch:implementing}










\chapter{Future considerations / current limitations}
\label{ch:limitations}
















\begin{todo}
    


    \begin{itemize}
        \item Universe polymorphic HeadT
        
        \item Quotients don't work yet
              \begin{itemize}
                \item datatypes involving quotients should be marked \texttt{noncomputable}, but this modifier is currently propagated to an autogenerated \inductive type, but Lean does not accept \lean{noncomputable inductive}.

                \item We should check which modifiers have to be propagated, and to which of the auto-generated types.
              \end{itemize}
        

        \item Mutually recursive types?
        
        \item User friendly (co)recursion / (co)induction
                \begin{itemize}
                    \item `eliminator`
                    \item integrate with equation compiler
                \end{itemize}
    \end{itemize}
\end{todo}









\chapter{Conclusion}
\label{ch:conclusion}















\begin{leanhidden}
    end Thesis
\end{leanhidden}



\bibliographystyle{ieeetr}
\bibliography{MScThesis}

\end{document}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "test"
%%% End: 
